<!DOCTYPE html>
<html lang="en">

<head>
	<link rel="manifest" href="/manifest.json">
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
<meta name="theme-color" content="#00bbff"><link rel="preload" href="/fonts/ibm-plex-serif-v8-latin-regular.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-serif-v8-latin-italic.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-serif-v8-latin-700.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-serif-v8-latin-700italic.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-sans-v7-latin-regular.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-sans-v7-latin-italic.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-sans-v7-latin-700.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-sans-v7-latin-200.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-mono-v5-latin-regular.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-mono-v5-latin-italic.woff2" as="font" type="font/woff2" crossorigin/><link rel="stylesheet" href="/css/fonts.css" />
<link rel="stylesheet" href="/css/compose.css" />
<link rel="stylesheet" href="/css/prism.css" />
<link rel="stylesheet" href="/css/customize.css" />
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width initial-scale=1">
<title>
    Ulf Schneider – Developer and Agile Coach
</title>

<script>
    if (navigator.serviceWorker) {
        navigator.serviceWorker.register('/serviceworker.js')
            .catch(error => {
                console.error(error);
            });
        addEventListener("load", function () {
            if (navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({ "command": "trimCache" });
            }
        });
    }
</script>
</head>

<body><a id="top" tabindex="-1"></a>
	<header class="mrb-3 bg-base-background x breakout-r z-1 pdy-d1 lh-4 small">
	<nav><span class="inline-block mrr-d1">
						<a href="/" class="no-deco meta">Ulf Schneider</a>
					</span><ul class="reset inline-block mry-0"><li class="inline-block">
							<a class="no-deco meta" href="/reading/">Reading</a>
						</li><li class="inline-block">
							<a class="no-deco meta" href="/articles/">Articles</a>
						</li><li class="inline-block">
							<a class="no-deco meta" href="/tools/">Tools</a>
						</li><li class="inline-block">
							<a class="no-deco meta" href="/journal/">Journal</a>
						</li><li class="inline-block">
							<a class="no-deco meta" href="/search/">Search</a>
						</li></ul>
</nav>
</header>

	<main class="x indent word-wrap default"><div class="breakout-l mrb-1">
			<div class="title no-indent"><h1 class="lh-2 fs-2 md:fs-4 md:lh-1 mrb-d2">A Sprint is not a milestone</h1><aside class="lh-2 small meta mrt-d2"><time class="no-wrap">April  9, 2011</time></aside></div>
		</div><p>By using Scrum, we deliver &quot;things&quot; in a rhythm that is given by so-called Sprints. Sprints should be of the same duration (for example two weeks) and at each Sprint ending there should be testable results. In the case of software development preferably working program code.</p>
<p>Usually, a development team has not only a concept for the things to deliver in the current Sprint. A rough idea for the delivery order of the next couple of Sprints can often be seen.</p>
<p>In organizations that are new to the concept of Sprints, this foresighted order can lead to the misunderstanding that Sprints need to be handled like milestones which define anticipated results of the project. This is a distorted understanding, and it makes the handling of Sprints for both – the Scrum team and the surrounding organization – difficult because it points into the wrong direction.</p>
<h2>These are the problems</h2>
<ul>
<li><strong>Reporting:</strong> The schedule and the achievement of milestones is reported to the organization, generally because other parties depend on these milestones to synchronize their work. In the case of „Sprint milestones“ we produce a chain of many milestones with short periods in between. If the Scrum team has a rough plan for the next three Sprints, but not for the subsequent ones, management tends to ask for further milestones until the end of the project. This forces the Scrum team to make an upfront project plan with Sprint milestones spanning the entire project duration. Of course, milestones need to be tracked because decisions will be made if the desired milestone achievements are not reached. Following that path, step by step the Scrum team will bring itself into a planning and reporting mode that does not help the team to deliver better and that does not support the organization to organize better. It merely produces more reporting and more reporting meetings.</li>
<li><strong>Inspect and adapt:</strong> Even though I don´t think any project has so many milestones, this understanding of software development as a defined process we can cope with by detailed upfront planning is precisely what we do not want to have. The real problem of Sprint milestones is in the denial of self-organizational forces. We want to leverage these forces by using transparency, inspection, and adaption. The possibility and necessity of continuous adjustment are what lets us learn and gain insights from our doing. The upfront Sprint milestone list will make inspect and adapt more difficult and therefore will make learning more expensive, it ignores the delivery velocity of the Scrum team and negates self-organizational forces. And it sometimes leads to the Scrumfall which is also a pattern to avoid.</li>
<li><strong>Scrumfall:</strong> In a Scrumfall the phases of the waterfall model are being organized into several subsequent Sprints. So you could have a first Sprint with requirements engineering, a second with analysis and design, next one implementation followed by a test Sprint and finally delivery. This is an anti-pattern, and we should understand that by following this working model the learning – which is an inherent part of any software development endeavor – is mostly being postponed to the last Sprint when we will see the final software result. Instead in Scrum, we want to go through all of the waterfall phases in each Sprint and deliver software, value, and outcome within each Sprint while learning to achieve better.</li>
</ul>
<blockquote>
<p>A Sprint is a sensor, not a milestone.</p>
</blockquote>
<p>The Sprint allows us to produce small, understandable and controllable results. And it enables us to inspect in relatively short feedback cycles how good we are doing. We can learn something from each finished Sprint and a Sprint without the achievement of desired software results may be a success, because we learned an important thing to do differently in the next Sprint.</p>
<p>And in the same sense a Sprint should be reported to the organization: As a sensor that tells us what is. A sensor that allows us to see, what has been done, what impediments are in our way and how we did better in comparison to previous Sprints.</p>
</main>

	<div class="x breakout-r">
		<footer class="mrt-1 mrb-2 lh-4 small"><nav>
		<ul class="mry-0 reset">
			<li class="inline-block"><a href="/feed.xml/" class="small no-deco meta">RSS</a></li><li class="inline-block"><a href="/colophon/" class="small no-deco meta">Colophon</a></li><li class="inline-block"><a href="/ownership/" class="small no-deco meta">Ownership</a></li><li id="load-time" class="inline-block small meta"></li>
		</ul>
		<a href="#top" id="back-to-top" style="display:none" class="small no-deco meta">Back to top</a>
<script>
    function maintainBackToTopVisibility() {
        let windowHeight = window.innerHeight;
        let documentHeight = document.body.clientHeight;
        let backToTop = document.getElementById('back-to-top');

        if (windowHeight * 1.5 < documentHeight) {
            backToTop.style.display = 'inline';
        } else {
            backToTop.style.display = 'none';
        }
    }

    maintainBackToTopVisibility();
    addEventListener('scroll', event => maintainBackToTopVisibility());
    addEventListener('resize', event => maintainBackToTopVisibility());

</script>
	</nav>
</footer>
	</div>

	<script src="/js/fit-vids.js"></script>
	<script src="/js/measure-load-time.js"></script>
</body>

</html>