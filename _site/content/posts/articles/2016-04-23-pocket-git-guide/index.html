<!DOCTYPE html>
<html lang="en">

<head>
	<link rel="manifest" href="/manifest.json">
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="apple-touch-icon" href="/apple-touch-icon.png" />
<meta name="theme-color" content="#00bbff"><link rel="preload" href="/fonts/ibm-plex-serif-v8-latin-regular.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-serif-v8-latin-italic.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-serif-v8-latin-700.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-serif-v8-latin-700italic.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-sans-v7-latin-regular.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-sans-v7-latin-italic.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-sans-v7-latin-700.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-sans-v7-latin-200.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-mono-v5-latin-regular.woff2" as="font" type="font/woff2" crossorigin/>
<link rel="preload" href="/fonts/ibm-plex-mono-v5-latin-italic.woff2" as="font" type="font/woff2" crossorigin/><link rel="stylesheet" href="/css/fonts.css" />
<link rel="stylesheet" href="/css/compose.css" />
<link rel="stylesheet" href="/css/prism.css" />
<link rel="stylesheet" href="/css/customize.css" />
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width initial-scale=1">
<title>
    Ulf Schneider – Developer and Agile Coach
</title>

<script>
    if (navigator.serviceWorker) {
        navigator.serviceWorker.register('/serviceworker.js')
            .catch(error => {
                console.error(error);
            });
        addEventListener("load", function () {
            if (navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({ "command": "trimCache" });
            }
        });
    }
</script>
</head>

<body><a id="top" tabindex="-1"></a>
	<header class="mrb-3 bg-base-background x breakout-r z-1 pdy-d1 lh-4 small">
	<nav><span class="inline-block mrr-d1">
						<a href="/" class="no-deco meta">Ulf Schneider</a>
					</span><ul class="reset inline-block mry-0"><li class="inline-block">
							<a class="no-deco meta" href="/reading/">Reading</a>
						</li><li class="inline-block">
							<a class="no-deco meta" href="/articles/">Articles</a>
						</li><li class="inline-block">
							<a class="no-deco meta" href="/tools/">Tools</a>
						</li><li class="inline-block">
							<a class="no-deco meta" href="/journal/">Journal</a>
						</li><li class="inline-block">
							<a class="no-deco meta" href="/search/">Search</a>
						</li></ul>
</nav>
</header>

	<main class="x indent word-wrap default"><div class="breakout-l mrb-1">
			<div class="title no-indent"><h1 class="lh-2 fs-2 md:fs-4 md:lh-1 mrb-d2">Pocket Git Guide</h1><aside class="lh-2 small meta mrt-d2"><time class="no-wrap">April 23, 2016</time></aside></div>
		</div><h2>Contents</h2>
<ul>
<li><a href="#reasons-to-use-git">Reasons to use Git</a></li>
<li><a href="#get-git-on-your-mac">Get Git on your Mac</a></li>
<li><a href="#get-git-on-windows">Get Git on Windows</a></li>
<li><a href="#the-git-shell">The Git shell</a></li>
<li><a href="#tell-git-who-you-are">Tell Git who you are</a></li>
<li><a href="#get-help-from-git">Get help from Git</a></li>
<li><a href="#create-a-new-local-repository">Create a new local repository</a></li>
<li><a href="#status-of-your-repository">Status of your repository</a></li>
<li><a href="#stage-to-tell-git-what-to-refer-to">Stage to tell Git what to refer to</a></li>
<li><a href="#commit-to-make-a-snapshot-of-your-work">Commit to make a snapshot of your work</a></li>
<li><a href="#the-commit-message">The commit message</a></li>
<li><a href="#removing-files">Removing files</a></li>
<li><a href="#renaming-files">Renaming files</a></li>
<li><a href="#ignoring-files">Ignoring files</a></li>
<li><a href="#branch-to-isolate">Branch to isolate</a></li>
<li><a href="#compare-your-working-directory">Compare your working directory</a></li>
<li><a href="#merge-to-include">Merge to include</a></li>
<li><a href="#remove-or-rename-a-branch">Remove or rename a branch</a></li>
<li><a href="#rewind-your-work">Rewind your work</a></li>
<li><a href="#working-with-remotes-to-share-with-a-team">Working with remotes to share with a team</a></li>
<li><a href="#clone-a-remote-repository-to-local">Clone a remote repository to local</a></li>
<li><a href="#push-data-to-remote">Push data to remote</a></li>
<li><a href="#pull-data-from-remote">Pull data from remote</a></li>
<li><a href="#the-big-picture">The big picture</a></li>
<li><a href="#command-reference">Commmand reference</a></li>
<li><a href="#references">References</a></li>
</ul>
<div class="breakout">
<h2>Reasons to use Git</h2>
Git will help you doing the following things with a computer:
<div class="x-12 mrt">
<div class="xx-12 rg:xx-6">
<h2 class="inline">Personal</h2>
<ul class="indent mrt-0">
<li>Keep track of file revisions when working iteratively (this is often referred to as version control).</li>
<li>Safely experiment because you can always step back to the previous version.</li>
<li>No need to give your files version indicating names, like essay_v1.txt, essay_v2.txt and so on.</li>
<li>It doesn´t play a role if you want to work on a single file or a multi-file project organized in multiple folders.</li>
<li>Convert any file or folder structure into a project that is under version control.</li>
<li>Have the advantage of powerful version control without the need to setup a server or creating an account somewhere.</li>
<li>Work consistently on multiple different operating systems, like MacOS, Linux and Windows.</li>
</ul>
</div>
<div class="xx-12 rg:xx-6">
<h2 class="inline">Team</h2>
<ul class="indent mrt-0">
<li>Share your work with others and keep track of their changes by enforcing the same set of rules for managing versions. This will work even with thousands of people on a big project, but also scales down nicely for a small team.</li>
<li>When sharing your work with others, you can work on your local computer without being always connected to a shared repository, only synchronizing eventually.</li>
<li>No central locking of files. All team members have their own working copy on their own computers which allows each of them to work independently.</li>
</ul>
</div>
</div>
</div>
<p>Git is free. You can get Git for any platform at <a href="https://git-scm.com/downloads">git-scm.com/downloads</a>.</p>
<h2>Get Git on your Mac</h2>
<p>I find it a little bit faster and more comfortable to use the <a href="https://desktop.github.com">GitHub Desktop Installer</a> for setting up Git on either Mac or Windows.</p>
<p>On a Mac, after installation, fire up GitHub Desktop, open the Preferences screen, go to the advanced tab and activate <em>Install Command Line Tools</em> to have the Git shell on your Mac. If you are using GitHub Desktop the first time, you can either install the command line tools from the welcome screen of GitHub Desktop.</p>
<p>Though not mandatory, for an improved Git experience in the shell, I like to have the following configured:</p>
<ul>
<li>The credential helper to cache my username and password, so I don´t have to provide it over and over again when using the https port while connecting to Git servers. See <a href="https://help.github.com/articles/caching-your-github-password-in-git/">Caching Your Git Password</a> for installation advice.</li>
<li>Bash Git Completion for an improved command prompt and command completion with the tab key. Follow <a href="https://github.com/bobthecow/git-flow-completion/wiki/Install-Bash-git-completion">Install Bash Git Completion</a> to get it set up (it includes a Git installation via homebrew, but you won´t need that one if you already installed GitHub Desktop like mentioned before). In addition to the explanations given, put the following lines to your <code>.bash_profile</code> to improve your command prompt:</li>
</ul>
<pre>export GIT_PS1_SHOWDIRTYSTATE=true
export GIT_PS1_SHOWUNTRACKEDFILES=true

PS1='\u@\h \W$(__git_ps1 " (%s)")\$ '</pre>
<h2>Get Git on Windows</h2>
<p>On Windows, the installation of <a href="https://desktop.github.com">GitHub Desktop</a> will bring Git and the GitHub Desktop Client on your machine. This all with minimal configuration effort for yourself. I think it´s a good starting point for your Git experience on Windows.</p>
<blockquote>
<p>No matter what platform you are using, all of the examples in this document are to be run from inside a command shell with access to Git.</p>
</blockquote>
<h2>The Git shell</h2>
<p>You can use a slick GUI client on top of Git, like for example <a href="https://www.git-tower.com">Tower</a> on a Mac or the reduced <a href="https://desktop.github.com">GitHub Desktop</a>. Sometimes things go faster and easier with a GUI client. Anyway, an advantage of the command shell is, it works the same on all platforms. What you learned here can be used anywhere. I assume it´s not so bad to start at the bottom to understand the tool right.</p>
<h2>Tell Git who you are</h2>
<pre>git config [--global] user.name ["your name or user name"]
git config [--global] user.email ["your email address"]</pre>
<p>Use the <code>--global</code> option to tell Git that the given configuration will be the default for all of your projects on your computer. After these settings have been made, your user data will be added to your commits. When you then push commits to a shared server, your name and email address will also appear on that server.</p>
<p>Detect your configuration settings with <code>git config --list</code>.</p>
<h2>Get help from Git</h2>
<p>You can type <code>git help &lt;command&gt;</code> to get access to user documentation about the specified <code>&lt;command&gt;</code>. To only get short info about the command syntax, use <code>git &lt;command&gt; -h</code>.</p>
<h2>Create a new local repository</h2>
<p>Move to the folder which should contain your project <code>cd /path/to/your/prj/</code>, then initialize the Git repository for the project with <code>git init</code>.</p>
<h2>Status of your repository</h2>
<p>When inside of a local Git repository <code>git status</code> will tell you what branch you are currently working on and give you an overview of untracked changes and outstanding commits.</p>
<h2>Working, staging and committing</h2>
<p>Versioning in Git is achieved by creating snapshots of your entire working directory. A snapshot is created with a <em>commit</em>. For files without changes, Git will maintain a reference to the previous snapshot. This means, each commit represents your entire working directory at that time, but stores only the files which have been changed. Technically speaking, Git maintains a <em>directed acyclic graph</em> of snapshots of your work.</p>
<figure>
<img src="https://ulf.codes/i/blog/git_commits_over_time.jpg" />
<figcaption>
Figure: Git produces snapshots of your entire project
</figcaption>
</figure>
<p>While you are working, Git divides your content into three main sections. Your working directory, your staging area (often referred to as <em>index</em>) and your committed work.</p>
<ul>
<li>Your working directory is merely the set of files and folders you operate on – your project.</li>
<li>The staging area is the set of changes which should go into the next commit.</li>
<li>Once you commit, Git will take the contents from the staging area and create a snapshot in the Git repository, which is then the committed revision of your project at the time of the commit.</li>
</ul>
<figure>
<img src="https://ulf.codes/i/blog/git_areas.jpg" />
<figcaption>Figure: Working – Staging – Committing</figcaption>
</figure>
<h2>Stage to tell Git what to refer to</h2>
<p>To prepare a snapshot of your current work, which will be stored in the Git repository, call <code>git add &lt;pathspec&gt;</code>.</p>
<p><code>&lt;pathspec&gt;</code> specifies the files to be put into the staging area (the index). Wildcards are allowed.</p>
<p>If a version of a file is not staged, Git doesn´t know how to refer to that version of the file and therefore you can´t commit it later on. Staged but uncommitted content remains only on your local computer and will not be sent to a remote repository somewhere else.</p>
<p>If you omit the <code>&lt;pathspec&gt;</code>, use <code>git add --all</code> which will ensure all untracked files in your current project are being added to your staging area.</p>
<p>The opposite of <code>git add</code> is <code>git reset &lt;pathspec&gt;</code>. With <code>git reset</code> you can un-stage contents.</p>
<p>If you created files or directories without staging them, and you want to get rid of them, use <code>git clean [-ifd]</code>.</p>
<p><code>-i</code> show what would be done and clean files interactively.</p>
<p><code>-f</code> if the git config <code>clean.requireForce false</code> is not set, this option is needed to proceed with the command.</p>
<p><code>-d</code> will also remove directories in addition to files.</p>
<h2>Commit to make a snapshot of your work</h2>
<p>You will commit very often, multiple times a day, sometimes within in minutes. It is the action you do most of the time when using Git.</p>
<p>Do not commit half-done, not-functioning work. Any commit should be a small solution for its own. As an example, a commit can contain the refactoring of a single method in your code or the rephrasing of a paragraph in a text document.</p>
<p>Contents which have been staged must be committed to produce a snapshot of your current work in the Git repository. Any commit is self-contained, it does not only reference your current changes but everything which makes up the state of your current project at the time you are committing. This is because each commit contains a pointer to its direct predecessor, the parent commit. Beginning at the most recent commit, the <em>tip</em>, the list of commits is a sequence pointing to the past, defining your entire project at the current time.</p>
<p>Commit with <code>git commit [-a] [-m &quot;your commit message&quot;]</code>.</p>
<p><code>-a</code> is a nice shorthand option even to stage content which has been modified or deleted without a previous <code>git add</code> command. New contents still need to be staged with the <code>git add</code> command. With <code>-m &quot;your commit message&quot;</code> you tell your co-workers and probably yourself why you made the commit.</p>
<p>An even shorter form of committing, in that case, is <code>git commit -am &quot;your commit message&quot;</code>.</p>
<p>Here the option to stage modified and deleted contents and the option to provide a commit message are combined in one option <code>-am</code>. You can combine multiple options in a single one like here, the only restriction is that only the last option can take an argument, like the commit message.</p>
<p>If you don´t specify a commit message when firing the commit command, an editor will be opened where you have to provide the commit message. You can configure the editor of your preference with <code>git config --global core.editor &lt;editor-name&gt;</code>.</p>
<p><a href="https://help.github.com/articles/associating-text-editors-with-git/">help.github.com/articles/associating-text-editors-with-git</a> provides a brief guide to setting up several editors. To see the currently configured editor, type <code>git config [--global] core.editor</code>.</p>
<p>Once you configured your preferred editor, you can not only write your commit messages by using it, you can also edit all of your configurations easily with the command <code>git config [--global] --edit</code>.</p>
<p>To see the history of commits use <code>git log</code>. The output of a <code>git log</code> can be filtered and formatted with <code>git log [--oneline] [--pretty] [&lt;branch-name&gt;]</code>.</p>
<p>For example <code>git log --oneline</code> will display most recent commits organized into one single line per commit.</p>
<p><code>git log --oneline &lt;branch-name&gt;</code> will display most recent commits in the specified branch, organized into one single line per commit.</p>
<p>A free formatting of the <code>git log</code> output can be achieved with <code>git log --pretty=&quot;&lt;your format string&gt;&quot;</code></p>
<p>A list of available formatting options is on <a href="https://git-scm.com/docs/pretty-formats">git-scm.com/docs/pretty-formats</a>.</p>
<h2>The commit message</h2>
<p>A <code>git log</code> of commit messages should give an idea of how the project has evolved. Each message explains <em>what</em> has been accomplished or changed with the commit. The message should describe a whole idea of completed work <a href="https://24ways.org/2014/dealing-with-emergencies-in-git/">[Westby 2014]</a>. Don´t describe <em>how</em> the change was accomplished – that´s in the code.</p>
<p>A properly formed commit subject line should complete the following sentence:</p>
<figure>
If applied, this commit will <code>&lt;your commit subject line&gt;</code>
</figure>
<p>The commit messages reveal whether a committer is a good collaborator or not.</p>
<p>Because in the output of a <code>git log</code> is not much space to display text and we do not have time to read through many sentences to understand what a commit was about, as a rule of thumb, the subject of the commit message should contain one line and 50 or fewer characters. Start the subject with a capital letter and do not end with a period.</p>
<p>Use the imperative mood, which means &quot;spoken or written as if giving a command or instruction.&quot; Examples:</p>
<ul>
<li>Repair css class assignment for git_hub image</li>
<li>No underline for slide navigation</li>
<li>Increase line height by a factor of 0.1</li>
</ul>
<p>If more explanation is needed, let a blank line follow the subject and then write the body of the commit message, wrapped at 72 characters per line, as Git will not wrap text automatically. Explain <em>why</em> the commit was made, again, not <em>how</em>.</p>
<p>In other words, follow the seven rules of a great Git commit message
<a href="http://chris.beams.io/posts/git-commit/#separate">[Beams 2014]</a>:</p>
<ol>
<li>Use the imperative mood in the subject line</li>
<li>Limit the subject to 50 characters</li>
<li>Capitalize the subject line</li>
<li>Do not end the subject line with a period</li>
<li>Separate the subject from the body with a blank line</li>
<li>Wrap the body at 72 characters</li>
<li>Use the body to explain <em>what and why</em> vs. <em>how</em></li>
</ol>
<h2>Removing files</h2>
<p>To delete a file from the working copy and the staging index, use <code>git rm &lt;pathspec&gt;</code>.</p>
<p><code>&lt;pathspec&gt;</code> describes the file or even files (wildcards allowed), which should be deleted. <code>git rm</code> will remove the file in your working copy and will stage the remove so that the removal can be committed in a subsequent commit. If you forgot to use <code>git rm</code> at first hand and instead removed the file with your usual remove command in the shell, the file will be removed from the working copy, but not from the staging index. In that case, you can even call <code>git rm &lt;pathspec&gt;</code> afterward, to have the file be removed from the index, as it is already removed from the file system.</p>
<h2>Renaming files</h2>
<p>If you rename a file in your command shell with <code>mv a.txt b.txt</code>, it will produce a similar situation as if you would remove a file with just the shell command <code>rm a.txt</code> and creating a new file <code>b.txt</code>. Git would still try to keep track of <code>a.txt</code>. To fix this, you would have to</p>
<pre>git rm a.txt
git add b.txt</pre>
<p>Or, use the suitable Git command right from the start: <code>git mv a.txt b.txt</code> which can be generalized to <code>git mv &lt;current-path&gt; &lt;new-path&gt;</code></p>
<h2>Ignoring files</h2>
<p>If Git should ignore some files in your project, for example, because</p>
<ul>
<li>a process belonging to your project automatically creates the files,</li>
<li>the files contain credentials or</li>
<li>package managers anyway download the files,</li>
</ul>
<p>you can specify patterns inside of the <code>.gitignore</code> file to exclude these from Git version control. Each pattern is one line in the <code>.gitignore</code> file. The <code>.gitignore</code> usually is in the root of your Git project.</p>
<p>An example of the patterns your <code>.gitignore</code> may contain</p>
<pre>*.a
build/
doc/*.txt
doc/**/*.txt
!doc/todo.txt</pre>
<p>The meaning of the patterns:</p>
<ul>
<li><code>*.a</code> ignore files with extension <code>.a</code></li>
<li><code>build/</code> ignore all contents of the <code>build</code> directory</li>
<li><code>doc/*.txt</code> ignore all files with extension <code>.txt</code> inside of the <code>doc</code> directory</li>
<li><code>doc/**/*.txt</code> ignore all files with extension <code>.txt</code> inside of the <code>doc</code> directory and all sub-directories of <code>doc</code></li>
<li><code>!doc/todo.txt</code> do not ignore <code>todo.txt</code></li>
</ul>
<p>The <code>.gitignore</code> file itself should be under version control – so be aware of not putting <code>.gitignore</code> as a pattern into the <code>.gitignore</code> file.</p>
<h2>Branch to isolate</h2>
<p>Any contents in Git must be in a branch. The first branch of a Git repository is the <em>master</em> branch. Technically it is a branch like all other branches, but conceptually it is the primary, stable version of whatever is stored in the repository.</p>
<p>A commit will always be done inside of a particular branch. But while commits point to the past, a branch is a concept for the future. A branch is a virtual copy of your project, where commits can be made freely in isolation from whatever else may happen in the repository. You would create a branch to experiment with some new feature inside of your project, to fix a bug or to do other things which you want to have separated from everything else until you have indeed found what you are after in your branch.</p>
<p>While you can have multiple branches in your repository, there is always exactly one working branch in your local repository, which is the one you are currently working on. This is what is in your <em>working directory</em> or <em>working copy</em>. Any commit you make will be against the working branch.</p>
<p><code>git branch &lt;branch-name&gt; [&lt;commit&gt;]</code> will create a new branch for you. Choose a short descriptive branch name. The optional <code>&lt;commit&gt;</code> specifies a commit to start from. If you don´t give the <code>&lt;commit&gt;</code>, the branch will be created from the latest commit in the current branch.</p>
<figure>
<img src="https://ulf.codes/i/blog/git_new_branch.jpg" />
<figcaption>Figure: Creating a new branch with the name 'lazyload'</figcaption>
</figure>
<p><code>git branch &lt;branch-name&gt;</code> will not make the newly created branch your current working copy; therefore your next commit would not be against the new branch. To make the new branch the active working copy, you need to <code>git checkout &lt;branch-name&gt;</code> after you have created your branch. Whatever you commit from that point on will be inside of your new branch and nowhere else.</p>
<p>Again, there is a shorthand command for creating a branch and making it the current working copy all at once: <code>git checkout -b &lt;branch-name&gt;</code> will create a new branch and make it the current working copy.</p>
<figure>
<img src="https://ulf.codes/i/blog/git_branch_first_commit.jpg" />
<figcaption>Figure: First commit in the 'lazyload' branch</figcaption>
</figure>
<figure>
<img src="https://ulf.codes/i/blog/git_branch_first_commit_alternate.jpg" />
<figcaption>Figure: Alternate picture for the first commit in the 'lazyload' branch</figcaption>
</figure>
<figure>
<img src="https://ulf.codes/i/blog/git_branch_multiple_commits.jpg" />
<figcaption>Figure: Multiple commits in the 'lazyload' branch</figcaption>
</figure>
<p><code>git branch [-a|-r]</code> without any option this command will show you the current list of local branches with a <code>*</code> in front of the currently active branch. Local branches are the branches you are working on and where your commits go against. With <code>-r</code> the <em>remote tracking branches</em> will be shown. <code>-a</code> will show all local branches and all remote tracking branches.</p>
<p>Remote tracking branches are all branches from your remote server (please refer to <a href="#working-with-remotes-to-share-with-a-team">Working with remotes to share with a team</a>) which came with your most recent <code>git fetch</code> or <code>git pull</code> into your local repository (so they are called remote tracking, but indeed they are stored in your local repository). They are used to connect your work with a remote repository. Whenever you call <code>get status</code> and get a result like</p>
<pre>Your branch is ahead of 'origin/&lt;branch-name>' by 1 commit.
  (use "git push" to publish your local commits)</pre>
<p>Git has figured out a difference between your local branch and its counterpart, the remote tracking branch.</p>
<p>Remote tracking branches are named <em>origin/&lt;branch-name&gt;</em>. Don´t checkout such a branch via <code>git checkout origin/&lt;branch-name&gt;</code> – instead, do <code>git checkout &lt;branch-name&gt;</code> to make the remote tracking branch a local branch.</p>
<p>To see the history of commits in a branch-oriented tree format, use <code>git log --graph --oneline</code>.</p>
<p>The <code>--graph</code> option will produce the branch tree, and the <code>--oneline</code> option leads to each commit being displayed in a single line of the tree structure.</p>
<h2>Compare your working directory</h2>
<p><code>git diff</code> will indicate the differences between your working directory and your staging area.</p>
<p><code>git diff [&lt;branch-name or commit]</code> compares your working directory with <code>&lt;branch-name or commit&gt;</code>.</p>
<p><code>git diff &lt;older-commit&gt; &lt;newer-commit&gt;</code> will indicate the differences between the two commits.</p>
<p>I find myself now and then using one of the two options <code>--stat</code> or <code>--color-words</code> in conjunction with any of the above <code>git diff</code> commands.</p>
<p><code>--stat</code> will display a little statistic of changed files with numbers of lines added and removed.</p>
<p><code>--color-words</code> will indicate changes in files word by word, instead of line by line, which is the default.</p>
<h2>Merge to include</h2>
<p>Sometimes the work which has been done in a branch will be thrown away. You delete the branch, and everything is as if the branch never existed. If you don´t want to throw away your work, you probably have to bring the contents of your branch into the master branch. That´s what merge is for. All commits that have been made in your source branch have to be merged into your master branch.</p>
<p>To merge any branch into your master branch, you have to</p>
<pre>git checkout master
git merge &lt;source-branch-name></pre>
<p>The first command will bring you into the master branch; the second command will pull in the changes from the source branch into the master branch. The principle is always the same – make the branch into which you want to merge the working copy and then pull changes from any other branch into your working copy by</p>
<pre>git checkout &lt;destination-branch-name>
git merge &lt;source-branch-name></pre>
<p>To be more precise, all commits from your source branch will be merged into your working copy, which is the checked out branch.</p>
<p>The simplest kind of merge is if nothing had been changed in the destination branch while you were working inside of the source branch.</p>
<figure>
<img src="https://ulf.codes/i/blog/git_fast_forward.jpg"/>
<figcaption>Figure: Fast-forward merge of 'lazyload' into 'master' branch</figcaption>
</figure>
<p>In this case, any changes made in the source branch will entirely be added to the destination branch, which is called <em>fast-forward</em>. The tip (last commit, or head commit) of the destination branch and the tip of the source branch will point to the same commit then, which is the last commit that was made in the source branch. After that, both branches, the source branch and the destination branch, are identical except in their branch names.</p>
<p>A <em>true merge</em> is something different. That´s when both, the source branch and the destination branch, have been modified before merging.</p>
<figure>
<img src="https://ulf.codes/i/blog/git_true_merge.jpg"/>
<figcaption>Figure: 'master' and 'lazyload' have been modified – a true merge is needed</figcaption>
</figure>
<p>A fast-forward then is no longer possible, and Git has to figure out the combined state of the content, which will lead to a so-called <em>merge commit</em>.</p>
<figure>
<img src="https://ulf.codes/i/blog/git_merge_commit.jpg" />
<figcaption>Figure: After a true merge of 'master' and 'lazyload' a merge commit was created</figcaption>
</figure>
<p>Each changed file in each branch is compared. When Git identifies a line that has changed in either branch, that line is carried forward for inclusion in the destination merge.</p>
<figure>
<img src="https://ulf.codes/i/blog/git_merge_line_by_line.jpg" />
<figcaption>Figure: A true merge goes line-by-line</figcaption>
</figure>
<p>As long as the branches don´t both contain changes to the same line, Git will merge and commit automatically with a generated commit message: <code>Merge branch '&lt;source-branch-name&gt;' into '&lt;destination-branch-name&gt;'.</code></p>
<p>Unlike a regular commit, which has one parent commit, a merge commit has two parent commits.</p>
<p>Now, when two modified lines of the same file are overlapping during a merge, a <em>merge conflict</em> occurs. Git can not automatically solve this conflict. Instead, Git indicate the conflict in the console</p>
<pre>CONFLICT (content): Merge conflict in &lt;conflicting-file-name-in-destination-branch>
Automatic merge failed; fix conflicts and then commit the result.</pre>
<p>and put a <em>conflict marker</em> into the file of the destination branch, indicating the conflicting lines.</p>
<h1><pre>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
&lt;conflicting content line in destination-branch (the current working copy)&gt;</h1>
<p>&lt;conflicting content line in source-branch&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>&lt;destination-branch-name&gt;</pre></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>To resolve the conflict, this entire section, including the angle brackets, needs to be edited and refactored into the final version you want to see in the file. After that, you can commit the merge with <code>commit -am &quot;your merge commit message&quot;</code>.</p>
<h2>Remove or rename a branch</h2>
<p>Sometimes you want to remove a branch, e.g., after all work is done and the branch has been merged into the master. In order to go ahead, use <code>git branch -d &lt;branch-to-delete&gt;</code> to remove your local branch. To remove a remote branch (refer to <a href="#working-with-remotes-to-share-with-a-team">Working with remotes to share with a team</a>), use <code>git push origin --delete &lt;branch-to-delete&gt;</code>.</p>
<p>A rename of the current local branch can be achieved by <code>git branch -m &lt;new-branch-name&gt;</code>.</p>
<p>To have the renamed branch on the server, do</p>
<pre>git push origin &lt;new-branch-name>
git push origin --delete &lt;old-branch-name></pre>
<p>the second push with the <code>--delete</code> option will remove the old branch from the remote.</p>
<h2>Rewind your work</h2>
<p>The <code>git checkout</code> can not only be used to checkout an entire branch to drive further the work in this separate branch. <code>git checkout</code> is also a way to go back to the history of your work.</p>
<p><code>git checkout &lt;commit hash&gt;</code> will set your working directory into the state of the commit referred to with the commit hash (the code you see for each entry in the <code>git log</code>, something like c04ff32). You are working then in the so-called <em>detached HEAD</em> state. Git will inform you about <em>detached HEAD</em> with the following output:</p>
<pre>$ git checkout c04ff32
Note: checking out 'c04ff32'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name>

HEAD is now at c04ff32... New image for git committing over time</pre>
<p>Another way to use <code>git checkout</code> is to use it for files.</p>
<p><code>git checkout &lt;pathspec&gt;</code> will bring the file which is described by <code>&lt;pathspec&gt;</code> from the head of your current branch back into your working directory. This is useful to revert changes you did on a file while keeping the changes of other files you just modified in your working directory.</p>
<h2>Working with remotes to share with a team</h2>
<p>The Git working mode is offline by default. This is nice because you don´t need to have an account to sign in somewhere, you can start working with your repository.</p>
<p>A remote in the Git world is a physical copy of a repository. It may be on the same computer as the repository it was copied from (copying is named <em>cloning</em> in Git) or on a different computer far away. The essential part is, you can exchange data between the two repositories and keep them synchronized. Usually, a remote repository is placed on a server which is accessible by your team. Any new teammate initially will clone the repository from the server to his or her local machine. The Git name for this remote repository is usually <em>origin</em>. The origin has nothing special and is not distinct from the local repositories on the machines of each team member, except only by convention it is used as a hub to which the team members connect to synchronize their work with all others. This will happen in a way that team members are working locally on their own computers and eventually sync with the remote repository on the hub server by <em>pulling</em> and <em>pushing</em> committed content.</p>
<figure>
<img src="https://ulf.codes/i/blog/git_hub.jpg" />
<figcaption>Figure: Origin is a hub by convention</figcaption>
</figure>
<p>Remote repositories are usually <em>bare</em> repositories, they have no staging area and no working copy like local repositories because no one is working directly on the remote repository. To indicate a bare repository usually <em>.git</em> is being appended to the name of the repository.</p>
<p>A remote may be on <a href="https://github.com">GitHub</a> or on a self-hosted system you want to use as a hub.</p>
<h2>Clone a remote repository to local</h2>
<p>On your local machine move to the folder under which the remote repository should be cloned <code>cd /path/to/parent/</code>. Then clone the remote repository into the parent <code>git clone &lt;repo&gt; [&lt;new-folder-name&gt;]</code>.</p>
<p><code>&lt;new-folder-name&gt;</code> is the optional folder name of the cloned project on your computer.</p>
<p><code>&lt;repo&gt;</code> is the path to the remote repository and has one of the following structures, each standing for a different protocol:</p>
<pre>/path/to/repo.git
ssh://[user@]host.xz[:port]/path/to/repo.git
git://host.xz[:port]/path/to/repo.git
http[s]://host.xz[:port]/path/to/repo.git</pre>
<p>The first protocol is the <em>local</em> protocol. This is useful if the remote repository will reside on a shared filesystem to which every team member has access. The other protocols are obviously <em>ssh, git</em> and <em>http</em>. To learn more about these, please refer to <a href="https://git-scm.com/book/tr/v2/Git-on-the-Server-The-Protocols">&quot;Git on the server – the protocols&quot;</a>.</p>
<p>Sometimes you try to access a server via https, and the server is using a self-signed certificate. Git won´t accept this certificate but if you are sure about the server, for example, because the server is located in your local intranet, one possible solution is the following configuration in Git:</p>
<pre>cd /path/to/your/repo
git config http.sslVerify false</pre>
<p>As a global setting for your entire Git: <code>git config --global http.sslVerify false</code>.</p>
<p>Once you have cloned the remote to your computer, Git already configured the <em>origin</em> for your project. You can check that by</p>
<pre>cd /path/to/parent/&lt;repo>
git remote -v</pre>
<p>which will display the <em>fetch</em> and <em>push</em> addresses being bound to the symbolic name <em>origin</em>.</p>
<h2>Push data to remote</h2>
<p>If you are working on your local project and committed your changes to a branch you want to bring to the remote repository now; the general Git command format is <code>git push &lt;remote&gt; &lt;remote-branch-name&gt;</code>. This will push the contents of the local branch, your current working copy, into the <code>&lt;remote-branch-name&gt;</code> on the remote repository.</p>
<p>Assuming you worked on a branch named <em>lazyload</em> and are currently on that local branch, your command is <code>git push origin lazyload</code>.</p>
<p>As already mentioned, remote repositories do not have working copies or staging areas and no humans who will resolve merge conflicts. Therefore, if you push to a remote and Git can not merge with a simple <em>fast-forward</em>, Git will reject the push. The situation needs to be fixed by pulling down the changes from the remote and then trying to push again.</p>
<p>The local branch names and the remote branch names are not related in Git. Even though they share the same name, Git doesn´t know that they logically represent the same piece of work. Therefore in each push, you have to tell Git to what branch on the remote you want to push. You can configure each local branch of your Git to <em>track</em> its remote counterpart. Once you have done it for a branch, you can push and pull against the remote just by typing <code>git push</code> and <code>git pull</code> without further specifying the remote and remote branch name.</p>
<p>Specify the tracking with <code>git push -u origin lazyload</code> or, generally <code>git push -u &lt;remote&gt; &lt;remote-branch-name&gt;</code>.</p>
<p><code>-u</code> (alternatively <code>--set-upstream</code>) is the option which will set up the tracking relationship between your current local branch and the remote branch. You only need to do it once per local branch.</p>
<p>A particular case of pushing is to remove a branch from the remote, as the removing of the local branch doesn´t remove the branch on the remote. The command goes <code>git push origin --delete &lt;remote-branch-name&gt;</code>.</p>
<h2>Pull data from remote</h2>
<p>If you want to get the latest changes, e.g. from the <em>lazyload</em> branch on the remote repository, into your local branch, call <code>git pull origin lazyload</code> or, in general, <code>git pull &lt;remote&gt; &lt;remote-branch-name&gt;</code>.</p>
<p>Git will automatically merge the remote changes into your local branch. In case of a merge conflict, resolve the conflict marker in your local branch, stage, commit your change and push to the remote.</p>
<h2>The big picture</h2>
<figure>
<img src="https://ulf.codes/i/blog/git_big_picture.jpg" />
<figcaption>Figure: Git commands and their fields of operation</figcaption>
</figure>
<h2>Command reference</h2>
<p>The following list is by far not complete. Though I found myself using these commands and options most often. For a complete list please refer to <a href="https://git-scm.com/docs/">git-scm.com/docs/</a>.</p>
<h3>Create new local repo</h3>
<pre>cd /path/to/your/prj/
git init</pre>
<h3>Copy existing repo</h3>
<pre>cd /path/to/parent/
git clone &lt;repo&gt; [&lt;new-folder-name&gt;]</pre>
<p>Where <code>&lt;repo&gt;</code> is one of</p>
<pre>/path/to/repo.git
ssh://[user@]host.xz[:port]/path/to/repo.git
git://host.xz[:port]/path/to/repo.git
http[s]://host.xz[:port]/path/to/repo.git</pre>
<p>Watch out</p>
<pre>git config [--global] http.sslVerify false</pre>
<p>as one possible solution in case Git doesn´t allow you to connect to a repo via https.</p>
<h3>Status of repo</h3>
<pre>git status</pre>
<h3>Stage content</h3>
<pre>git add &lt;pathspec&gt;</pre>
<p>or</p>
<pre>git add --all</pre>
<p>to un-stage, use</p>
<pre>git reset &lt;pathspec&gt;</pre>
<h3>Removing files which have not been staged</h3>
<pre>git clean [-ifd]</pre>
<h3>Commit content</h3>
<pre>git commit [-a] [-m "your commit message"]</pre>
<p>where <code>-a</code> will stage all modified and deleted content and <code>-m</code> indicates the commit message, alternatively</p>
<pre>git commit -am "your commit message"</pre>
<h3>See history of commits</h3>
<pre>git log [--oneline] [--pretty] [&lt;branch-name&gt;]</pre>
<h3>Remove file</h3>
<pre>git rm &lt;pathspec&gt;</pre>
<h3>Rename file</h3>
<pre>git mv &lt;current-path&gt; &lt;new-path&gt;</pre>
<h3>Ignore file</h3>
<p>Use one pattern per line in .gitignore file</p>
<pre>*.a
build/
doc/*.txt
doc/**/*.txt
!doc/todo.txt</pre>
<h3>See what branch you are on</h3>
<pre>git branch [-a|-r]</pre>
<h3>Create a branch</h3>
<pre>git branch &lt;branch-name&gt; [&lt;commit&gt;]</pre>
<p>or</p>
<pre>git checkout -b &lt;branch-name&gt;</pre>
<p>to create and checkout the branch.</p>
<h3>Checkout a branch</h3>
<pre>git checkout &lt;branch-name&gt;</pre>
<h3>Compare changes</h3>
<pre>git diff [--stat] [&lt;branch-name or commit&gt;]
git diff &lt;older-commit&gt; &lt;newer-commit&gt;
</pre>
<h3>Merge</h3>
<pre>git checkout &lt;destination-branch-name&gt;
git merge &lt;source-branch-name&gt;
</pre>
<h3>Rename a branch</h3>
<pre>git -m &lt;branch-name&gt;</pre>
<h3>Delete a branch</h3>
<pre>git -d &lt;branch-name&gt;</pre>
<h3>Activate an older commit</h3>
<pre>git checkout &lt;commit-hash&gt;</pre>
<h3>Discard file changes</h3>
<pre>git checkout &lt;pathspec&gt;</pre>
<h3>Push to server</h3>
<pre>git push [-u] &lt;remote&gt; &lt;remote-branch-name&gt;</pre>
<p>to push from current branch to remote branch, where <code>-u</code> can be used once to track the remote branch from the current branch. After setting the upstream with <code>-u</code>, it can be pushed and pulled from the current branch without specifying <code>&lt;remote&gt;</code> and <code>&lt;remote-branch-name&gt;</code>.</p>
<h3>Pull from server</h3>
<pre>git pull &lt;remote&gt; &lt;remote-branch-name&gt;</pre>
<p>to pull from remote branch into current branch. If remote branch tracking has been activated before via <code>-u</code> in a <code>git push</code>, it can be pulled from the remote branch without specifying <code>&lt;remote&gt;</code> and <code>&lt;remote-branch-name&gt;</code>.</p>
<h3>Tell Git who you are</h3>
<pre>git config [--global] user.name ["your name or user name"]
git config [--global] user.email ["your email address"]</pre>
<h3>Display your Git config</h3>
<pre>git config --list</pre>
<h3>Edit your Git config file</h3>
<pre>git config [--global] --edit</pre>
<h3>Configure your editor</h3>
<p>Set your editor</p>
<pre>git config --global core.editor &lt;editor-name&gt;</pre>
<p>Display your current editor setting</p>
<pre>git config core.editor</pre>
<h3>Let Git accept your self-signed certificate</h3>
<pre>git config [--global] http.sslVerify false</pre>
<h2>References</h2>
<p>[Atlassian Git]
: &quot;Getting Git Right,&quot; Altassian Git Tutorial, <a href="https://www.atlassian.com/git/">atlassian.com/git</a></p>
<p>[Bash Git Completion]
: &quot;Install Bash Git Completion,&quot; <a href="https://github.com/bobthecow/git-flow-completion/wiki/Install-Bash-git-completion">github.com/bobthecow/git-flow-completion/wiki/Install-Bash-git-completion</a></p>
<p>[Beams 2014]
: C. Beams, &quot;How to Write a Git Commit Message,&quot; 2014, <a href="http://chris.beams.io/posts/git-commit/">chris.beams.io/posts/git-commit</a></p>
<p>[Caching Your Git Password]
: &quot;Caching your GitHub password in Git,&quot; <a href="https://help.github.com/articles/caching-your-github-password-in-git/">help.github.com/articles/caching-your-github-password-in-git/</a></p>
<p>[Chacon, Straub 2014]
: S. Chacon, B. Straub, &quot;Pro Git,&quot; 2014, <a href="https://git-scm.com/book">git-scm.com/book</a></p>
<p>[Cheat Sheet]
: &quot;Git Cheat Sheet,&quot; <a href="https://www.git-tower.com/blog/git-cheat-sheet/">www.git-tower.com/blog/git-cheat-sheet/</a></p>
<p>[Demaree 2016]
: D. Demaree, “Git for Humans”, A Book Apart, 2016, <a href="https://abookapart.com/products/git-for-humans">abookapart.com/products/git-for-humans</a></p>
<p>[GitHub]
: &quot;Welcome home, developers,&quot; <a href="https://github.com">github.com</a></p>
<p>[GitHub Desktop]
: &quot;Simple collaboration from your desktop,&quot; <a href="https://desktop.github.com">desktop.github.com</a></p>
<p>[GitRef]
: Git command reference, <a href="https://git-scm.com/docs/">git-scm.com/docs/</a></p>
<p>[Git]
: Git downloads for different platforms, <a href="https://git-scm.com">git-scm.com/downloads</a></p>
<p>[Learn]
: &quot;Learn Git &amp; Version Control,&quot; <a href="https://www.git-tower.com/learn/">www.git-tower.com/learn/</a></p>
<p>[Tower]
: Version control with Git – made easy,
In a beautiful, efficient, and powerful app, <a href="https://www.git-tower.com">git-tower.com</a></p>
<p>[Westby 2014]
: E. J. Westby, &quot;Dealing with Emergencies in Git,&quot; 2014 <a href="https://24ways.org/2014/dealing-with-emergencies-in-git/">24ways.org/2014/dealing-with-emergencies-in-git/</a></p>
</main>

	<div class="x breakout-r">
		<footer class="mrt-1 mrb-2 lh-4 small"><nav>
		<ul class="mry-0 reset">
			<li class="inline-block"><a href="/feed.xml/" class="small no-deco meta">RSS</a></li><li class="inline-block"><a href="/colophon/" class="small no-deco meta">Colophon</a></li><li class="inline-block"><a href="/ownership/" class="small no-deco meta">Ownership</a></li><li id="load-time" class="inline-block small meta"></li>
		</ul>
		<a href="#top" id="back-to-top" style="display:none" class="small no-deco meta">Back to top</a>
<script>
    function maintainBackToTopVisibility() {
        let windowHeight = window.innerHeight;
        let documentHeight = document.body.clientHeight;
        let backToTop = document.getElementById('back-to-top');

        if (windowHeight * 1.5 < documentHeight) {
            backToTop.style.display = 'inline';
        } else {
            backToTop.style.display = 'none';
        }
    }

    maintainBackToTopVisibility();
    addEventListener('scroll', event => maintainBackToTopVisibility());
    addEventListener('resize', event => maintainBackToTopVisibility());

</script>
	</nav>
</footer>
	</div>

	<script src="/js/fit-vids.js"></script>
	<script src="/js/measure-load-time.js"></script>
</body>

</html>